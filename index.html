<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gộp Excel → Xuất theo “Lượt bán” + lọc “Giá” (tải tuần tự)</title>
  <style>
    :root{--bg:#0b1020;--card:#121830;--muted:#7c8db5;--txt:#e9eefb;--line:#1b2340}
    body{font:14px/1.5 system-ui,Roboto,Arial;background:var(--bg);color:var(--txt);margin:0}
    .wrap{max-width:1100px;margin:22px auto;padding:0 16px}
    h1{margin:0 0 8px}
    .card{background:#121830;border:1px solid var(--line);border-radius:12px;padding:16px;margin:16px 0}
    input[type=file], input[type=text]{width:100%;margin:6px 0;padding:10px;border-radius:8px;border:1px solid #223;background:#0d1330;color:var(--txt)}
    button{margin:6px 4px;padding:10px 14px;border-radius:8px;border:1px solid #235;background:#1b2550;color:#fff;cursor:pointer}
    button:disabled{opacity:.55;cursor:not-allowed}
    .pill{display:inline-block;margin:2px;padding:4px 10px;background:#0e1a42;border:1px solid #223;border-radius:999px;font-size:12px;color:#a8b4d6}
    .note{color:var(--muted);font-size:13px}
    #bucketCounts .pill{margin-right:6px}
    .grid{display:grid;gap:10px}
    .grid-2{grid-template-columns:1fr 1fr}
    label.inline{display:inline-flex;align-items:center;gap:6px}
  </style>

  <!-- (Tuỳ chọn) DÁN xlsx.full.min.js vào đây để chạy OFFLINE -->
  <script id="SHEETJS_INLINE" type="text/plain"></script>
</head>
<body>
<div class="wrap">
  <h1>📊 Gộp Excel → Xuất theo “Lượt bán” + lọc “Giá” (tải tuần tự)</h1>

  <section class="card">
    <p class="note">
      Cột A: tiêu đề <code>Lượt bán …</code> (≥, &lt;, A–B, ≥A và &lt;B). Dưới mỗi tiêu đề là list link. Bên trong có thể có tiêu đề con <code>Giá …</code> (≥, &lt;, A–B). Link không có tiêu đề Giá sẽ vào “Giá (không xác định)”.<br>
      Dãy “Lượt bán” có thể nhập (mặc định: 1000,750,500,350,150,60,40,20,5,1). Dãy “Giá” dùng cố định theo yêu cầu.
    </p>

    <div class="grid grid-2">
      <div>
        <input type="file" id="excelFiles" accept=".xls,.xlsx,.csv" multiple>
        <label class="inline"><input id="stripParams2" type="checkbox" checked> Chuẩn hoá URL khi trùng (bỏ query/hash)</label>
        <div id="fileList"></div>
      </div>

      <div>
        <label>Dãy ngưỡng Lượt bán (giảm dần):</label>
        <input id="thresholdsInput" type="text" value="1000,750,500,350,150,60,40,20,5,1" />
        <div class="note">Để trống nếu muốn tự suy từ tiêu đề trong file.</div>
      </div>
    </div>

    <button id="btnProcess">Xử lý & Xuất</button>
    <div id="mergeStatus" class="note"></div>
    <div id="bucketCounts"></div>
  </section>
</div>

<script>
/* ===== Load SheetJS (inline hoặc CDN) ===== */
(async function bootstrapXLSX(){
  if (window.XLSX) return;
  const inline = document.getElementById('SHEETJS_INLINE')?.textContent || '';
  if (inline && /xlsx\.(?:version|utils|read)/.test(inline)) { (0, eval)(inline); return; }
  const cdnList = [
    "https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js",
    "https://fastly.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js",
    "https://unpkg.com/xlsx/dist/xlsx.full.min.js",
    "https://esm.run/xlsx",
    "https://esm.sh/xlsx"
  ];
  for (const src of cdnList) {
    try {
      if (src.endsWith('.js')) {
        await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>res(); s.onerror=()=>rej(); document.head.appendChild(s); });
      } else {
        const mod = await import(src);
        if (mod && (mod.read || mod.utils)) window.XLSX = mod;
      }
      if (window.XLSX) return;
    } catch(e){}
  }
  console.warn('Không tải được SheetJS từ CDN. Hãy dán xlsx.full.min.js vào SHEETJS_INLINE để chạy offline.');
})();

/* ================== Helpers ================== */
function numVN(s){ if (s==null) return NaN; const m=String(s).match(/-?\d+/g); if(!m) return NaN; const n=parseInt(m.join(''),10); return isFinite(n)?n:NaN; }
function tryParseURL(u){try{return new URL(u.trim())}catch{return null}}
function normalizeURL(u, drop=true){ const url=tryParseURL(u); if(!url) return (u||'').trim(); if(drop){url.search=''; url.hash='';} url.hostname=url.hostname.toLowerCase(); return url.toString(); }
function fmtIntVN(n){ if (!isFinite(n)) return (n>0?'+∞':'-∞'); return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g,'.'); }
function uniqSortedDesc(nums){ return [...new Set(nums.filter(x=>isFinite(x)))].sort((a,b)=>b-a); }

function keyOfRange(r){ const l=isFinite(r.low)?r.low:(r.low===-Infinity?'NEG_INF':'UNK'); const u=isFinite(r.up)?r.up:(r.up===Infinity?'POS_INF':'UNK'); return `${l}|${u}`; }
function rangesIntersect(a,b){ const lowA=isFinite(a.low)?a.low:-Infinity, upA=isFinite(a.up)?a.up:Infinity; const lowB=isFinite(b.low)?b.low:-Infinity, upB=isFinite(b.up)?b.up:Infinity; return lowA<upB && lowB<upA; }

// tên file ASCII an toàn + unique trong phiên
function toAscii(str){ return str.normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/đ/g,'d').replace(/Đ/g,'D'); }
function safeFilenameBase(name){
  const replaced = name
    .replace(/≥|>=/g,' ge ')
    .replace(/≤|<=/g,' le ')
    .replace(/>/g,' gt ')
    .replace(/</g,' lt ')
    .replace(/[–—]/g,'-')
    .replace(/\s+/g,' ')
    .trim();
  let ascii = toAscii(replaced).replace(/[^\w\s.-]/g,' ').replace(/\s+/g,'_');
  if (!ascii.toLowerCase().endsWith('.xlsx')) ascii += '.xlsx';
  ascii = ascii.replace(/[<>:"/\\|?*\u0000-\u001F]/g,'-');
  return ascii;
}
function makeUniqueName(name, used){
  let base = safeFilenameBase(name);
  if (!used.has(base)){ used.add(base); return base; }
  const m = base.match(/^(.*?)(?:\s\((\d+)\))?(\.xlsx)$/i);
  const head = m ? m[1].trim() : base.replace(/\.xlsx$/i,'');
  const ext = '.xlsx';
  let i = 2, cand = `${head} (${i})${ext}`;
  while (used.has(cand)) { i++; cand = `${head} (${i})${ext}`; }
  used.add(cand);
  return cand;
}

/** Parser tiêu đề số cho “Lượt bán …” / “Giá …” */
function parseHeaderToRangeBase(line, keywordRegex){
  const s=(line||'').replace(/\s+/g,' ').trim();
  if(!keywordRegex.test(s)) return null;

  let m = s.match(/(?:≥|>=|&ge;|&amp;ge;)\s*([\d.,\s]+)\s*(?:và|and)?\s*(?:<|&lt;)\s*([\d.,\s]+)/i);
  if (m){ const a=numVN(m[1]), b=numVN(m[2]); if(isFinite(a)&&isFinite(b)){ const low=Math.min(a,b), up=Math.max(a,b); return {low,up}; } }

  m = s.match(/([\d.,\s]+)\s*[-–]\s*([\d.,\s]+)/i);
  if (m){ const a=numVN(m[1]), b=numVN(m[2]); if(isFinite(a)&&isFinite(b)){ const low=Math.min(a,b), up=Math.max(a,b); return {low,up}; } }

  m = s.match(/(?:<|&lt;)\s*([\d.,\s]+)/i);
  if (m){ const z=numVN(m[1]); if(isFinite(z)) return {low:-Infinity, up:z}; }

  m = s.match(/(?:≥|>=|&ge;|&amp;ge;|>|&gt;)\s*([\d.,\s]+)/i);
  if (m){ const x=numVN(m[1]); if(isFinite(x)) return {low:x, up:Infinity}; }

  return null;
}
function parseSalesHeader(line){ return parseHeaderToRangeBase(line, /lượt bán/i); }
function parsePriceHeader(line){ return parseHeaderToRangeBase(line, /(^|\s)giá(\s|:)/i); }

function labelOfSalesRange(r){
  const low=isFinite(r.low)?r.low:-Infinity, up=isFinite(r.up)?r.up:Infinity;
  if (up===Infinity) return `Lượt bán ≥ ${fmtIntVN(low)}`;
  if (low===-Infinity) return `Lượt bán < ${fmtIntVN(up)}`;
  return `Lượt bán từ ${fmtIntVN(low)} đến ${fmtIntVN(up)}`;
}
function labelOfPriceRange(r){
  const low=isFinite(r.low)?r.low:-Infinity, up=isFinite(r.up)?r.up:Infinity;
  if (up===Infinity) return `Giá > ${fmtIntVN(low)}`;
  if (low===-Infinity) return `Giá < ${fmtIntVN(up)}`;
  return `Giá ${fmtIntVN(low)} – ${fmtIntVN(up)}`;
}

/* ================== Đọc Excel ================== */
const excelInput=document.getElementById('excelFiles');
const fileList=document.getElementById('fileList');
excelInput.onchange=()=>{ fileList.innerHTML=''; for(const f of excelInput.files){ const s=document.createElement('span'); s.className='pill'; s.textContent=f.name; fileList.appendChild(s); } };

/** Map<salesKey, { range:Range, priceMap: Map<priceKey, { range:Range|null, links:Set }>, unknown:Set }> */
async function parseExcel(file){
  if (!window.XLSX) throw new Error('SheetJS chưa sẵn sàng.');
  const buf=await file.arrayBuffer();
  const wb=XLSX.read(buf,{type:'array'});
  const ws=wb.Sheets[wb.SheetNames[0]];
  const rows=XLSX.utils.sheet_to_json(ws,{header:1,raw:false,defval:'',blankrows:false});

  const lines=[];
  for(const r of rows){
    const a=(r&&r[0]!=null?String(r[0]):'').trim();
    if(!a) continue;
    const parts=a.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    for(const p of parts) lines.push(p);
  }

  const salesMap = new Map();
  let currentSales = null;
  let currentPrice = null;

  function ensureSales(range){
    const k = keyOfRange(range);
    if (!salesMap.has(k)) salesMap.set(k, { range, priceMap: new Map(), unknown: new Set() });
    return salesMap.get(k);
  }
  function ensurePrice(salesObj, priceRange){
    const pkey = priceRange? keyOfRange(priceRange) : 'UNKNOWN';
    if (priceRange){
      if (!salesObj.priceMap.has(pkey)) salesObj.priceMap.set(pkey, { range: priceRange, links: new Set() });
      return salesObj.priceMap.get(pkey);
    } else {
      return { range: null, links: salesObj.unknown };
    }
  }

  for (const line of lines){
    const sRange = parseSalesHeader(line);
    if (sRange){ currentSales = ensureSales(sRange); currentPrice = null; continue; }

    const pRange = parsePriceHeader(line);
    if (pRange){ if (!currentSales) continue; currentPrice = ensurePrice(currentSales, pRange); continue; }

    if (currentSales && /^https?:\/\//i.test(line)) {
      (currentPrice ? currentPrice.links : currentSales.unknown).add(line.trim());
    }
  }
  return salesMap;
}

/* ================== Gộp & tái-bucket ================== */
const PRICE_DEFAULTS = [5000000,1000000,500000,200000,100000,50000,20000];

function dedupeAndNormalizeNested(map, dropParams){
  const out=new Map();
  for (const [sk, sobj] of map.entries()){
    const sobj2 = { range: sobj.range, priceMap: new Map(), unknown: new Set() };
    for (const u of sobj.unknown) sobj2.unknown.add(normalizeURL(u, dropParams));
    for (const [pk, pobj] of sobj.priceMap.entries()){
      const set=new Set();
      for (const u of pobj.links) set.add(normalizeURL(u, dropParams));
      sobj2.priceMap.set(pk, { range: pobj.range, links: set });
    }
    out.set(sk, sobj2);
  }
  return out;
}
function unifyAcrossFiles(listOfMaps){
  const merged = new Map();
  for (const mp of listOfMaps){
    for (const [sk, sobj] of mp.entries()){
      if (!merged.has(sk)) merged.set(sk, { range: sobj.range, priceMap: new Map(), unknown: new Set() });
      const dest = merged.get(sk);
      for (const u of sobj.unknown) dest.unknown.add(u);
      for (const [pk, pobj] of sobj.priceMap.entries()){
        if (!dest.priceMap.has(pk)) dest.priceMap.set(pk, { range: pobj.range, links: new Set() });
        const d = dest.priceMap.get(pk);
        for (const u of pobj.links) d.links.add(u);
      }
    }
  }
  return merged;
}
function buildRangesFromThresholds(thrs){
  const out=[]; if (!thrs.length) return out;
  let prev = Infinity; for (const t of thrs){ out.push({ low:t, up:prev }); prev = t; }
  out.push({ low:-Infinity, up: thrs[thrs.length-1] }); return out;
}
function buildPriceRanges(){
  const thrs = PRICE_DEFAULTS;
  const out=[]; let prev = Infinity;
  for (const t of thrs){ out.push({ low:t, up:prev }); prev = t; }
  out.push({ low:-Infinity, up: thrs[thrs.length-1] }); return out;
}

/* ================== Tạo XLSX (Blob) + tải tuần tự ================== */
function makeXLSXBlob(rowsColA){
  const ws=XLSX.utils.aoa_to_sheet(rowsColA.map(x=>[x]));
  const wb=XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb,ws,'Data');
  const wbout = XLSX.write(wb,{bookType:'xlsx',type:'array'});
  return new Blob([wbout],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
}
function triggerDownload(blob, filename){
  return new Promise(resolve=>{
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=filename; document.body.appendChild(a);
    a.click();
    // give the browser a tick to start the download before revoking
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); resolve(); }, 100);
  });
}
const sleep = ms => new Promise(r=>setTimeout(r, ms));
async function downloadBlobSequential(files){ // files: [{blob, name}]
  for (const f of files){
    await triggerDownload(f.blob, f.name);
    await sleep(350); // 👈 khoảng nghỉ giữa các lần tải
  }
}

/* ================== Orchestrator ================== */
const btnProcess=document.getElementById('btnProcess');
const statusMerge=document.getElementById('mergeStatus');
const bucketCounts=document.getElementById('bucketCounts');
const thresholdsInput=document.getElementById('thresholdsInput');

btnProcess.onclick=async()=>{
  const files=[...excelInput.files];
  if(!files.length){ statusMerge.textContent='Hãy chọn ít nhất 1 file Excel.'; return; }

  statusMerge.textContent='Đang đọc & gộp dữ liệu…';
  btnProcess.disabled=true; bucketCounts.innerHTML='';

  const parsedMaps=[];
  for(const f of files){
    try{ parsedMaps.push(await parseExcel(f)); }catch(e){ console.error('Lỗi file', f.name, e); }
  }

  const mergedRaw = unifyAcrossFiles(parsedMaps);
  const merged = dedupeAndNormalizeNested(mergedRaw, document.getElementById('stripParams2').checked);

  // Dãy ngưỡng Lượt bán
  let thrs = String(thresholdsInput.value||'').split(',').map(s=>numVN(s)).filter(x=>isFinite(x));
  thrs = uniqSortedDesc(thrs);

  if (!thrs.length){
    const lows=[]; for (const {range} of merged.values()) if (isFinite(range.low)) lows.push(range.low);
    thrs = uniqSortedDesc(lows);
    statusMerge.innerHTML = thrs.length ? `Tự suy ra dãy ngưỡng Lượt bán: ${thrs.join(', ')}` : 'Không tìm thấy ngưỡng Lượt bán nào. Sẽ xuất 1 file “Không xác định”.';
    if (!thrs.length){
      const allLinks = new Set();
      for (const sobj of merged.values()){
        for (const u of sobj.unknown) allLinks.add(u);
        for (const pobj of sobj.priceMap.values()) for (const u of pobj.links) allLinks.add(u);
      }
      const rows = [];
      for (const pr of buildPriceRanges()) rows.push(labelOfPriceRange(pr));
      if (allLinks.size){ rows.push('Giá (không xác định)'); for (const u of allLinks) rows.push(u); }
      const filesToDl = [{ blob: makeXLSXBlob(rows), name: makeUniqueName('Khong_xac_dinh.xlsx', new Set()) }];
      await downloadBlobSequential(filesToDl);
      btnProcess.disabled=false; return;
    }
  } else {
    statusMerge.innerHTML = `Dùng dãy ngưỡng Lượt bán: ${thrs.join(', ')}`;
  }

  const outSalesRanges = buildRangesFromThresholds(thrs);
  const outPriceRanges = buildPriceRanges();

  // Chuẩn bị cấu trúc đích
  const outMap = new Map(outSalesRanges.map(sr=>[labelOfSalesRange(sr), {
    prices: new Map(outPriceRanges.map(pr=>[labelOfPriceRange(pr), new Set()])),
    unknown: new Set()
  }]));

  // Phân bổ
  for (const sobj of merged.values()){
    for (const srOut of outSalesRanges){
      if (!rangesIntersect(sobj.range, srOut)) continue;
      const destSales = outMap.get(labelOfSalesRange(srOut));
      for (const u of sobj.unknown) destSales.unknown.add(u);
      for (const pobj of sobj.priceMap.values()){
        let matched = false;
        for (const prOut of outPriceRanges){
          if (rangesIntersect(pobj.range, prOut)){
            const bucket = destSales.prices.get(labelOfPriceRange(prOut));
            for (const u of pobj.links) bucket.add(u);
            matched = true; break;
          }
        }
        if (!matched){ for (const u of pobj.links) destSales.unknown.add(u); }
      }
    }
  }

  // Chuẩn bị danh sách file và tải tuần tự
  const usedNames = new Set();
  const filesToDownload = [];
  bucketCounts.innerHTML = '';
  const mk=(label,n)=>{const s=document.createElement('span');s.className='pill';s.textContent=`${label}: ${n}`;return s};

  for (const srOut of outSalesRanges){
    const sLabel = labelOfSalesRange(srOut);
    const dest = outMap.get(sLabel);

    const total = new Set();
    for (const set of dest.prices.values()) for (const u of set) total.add(u);
    for (const u of dest.unknown) total.add(u);

    const rows = [];
    for (const prOut of outPriceRanges){
      const pLabel = labelOfPriceRange(prOut);
      rows.push(pLabel);
      const links = [...(dest.prices.get(pLabel)||new Set())];
      for (const u of links) rows.push(u);
    }
    if (dest.unknown.size){
      rows.push('Giá (không xác định)');
      for (const u of dest.unknown) rows.push(u);
    }

    const blob = makeXLSXBlob(rows);
    const fname = makeUniqueName(`${sLabel}.xlsx`, usedNames);
    filesToDownload.push({ blob, name: fname });

    bucketCounts.append(mk(sLabel, total.size));
  }

  await downloadBlobSequential(filesToDownload);
  statusMerge.innerHTML += ' ✅ Đã tải tuần tự đầy đủ các file (bao gồm bucket < 1).';
  btnProcess.disabled=false;
};
</script>
</body>
</html>
